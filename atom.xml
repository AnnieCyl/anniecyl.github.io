<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Annie&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/3da1370d794727fa8387611ff601acf0</icon>
  <subtitle>good good study, day day up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://anniecyl.github.io/"/>
  <updated>2020-12-15T06:09:26.894Z</updated>
  <id>http://anniecyl.github.io/</id>
  
  <author>
    <name>Annie</name>
    <email>289927039@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UML</title>
    <link href="http://anniecyl.github.io/2020/12/15/UML/"/>
    <id>http://anniecyl.github.io/2020/12/15/UML/</id>
    <published>2020-12-15T02:37:15.000Z</published>
    <updated>2020-12-15T06:09:26.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>总是记不住 UML 那些图例呀，每次要画 UML 图了，就得再上网找一番，索性自己整理一下好了，方便以后查阅。</p><h2 id="访问修饰符表示"><a href="#访问修饰符表示" class="headerlink" title="访问修饰符表示"></a>访问修饰符表示</h2><p>成员变量以及方法前的访问修饰符用符号来表示：</p><ul><li><code>+</code> 表示 <code>public</code></li><li><code>-</code> 表示 <code>private</code></li><li><code>#</code> 表示 <code>protected</code></li></ul><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><p><img src="/img/2020-12-15-uml/relation.png" alt="relation"></p><h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系表现为<strong>继承非抽象类</strong>，也就是 <code>is-a</code> 的关系，e.g.：汽车在现实中有实现，可用汽车定义具体的对象；汽车与 SUV 之间为泛化关系，用一条带空心箭头的直线表示，如下图表示：SUV 继承自汽车，SUV 也是一种汽车。</p><p><img src="/img/2020-12-15-uml/is-a.png" width="50%" style="margin: 0 auto;"></p><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系表现为<strong>继承抽象类</strong>，e.g.：“车”为一个抽象概念，无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才 可以用来定义对象。实现关系用一条带空心箭头的虚线表示。</p><p><img src="/img/2020-12-15-uml/realize.png" width="50%" style="margin: 0 auto;"></p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系表示整体由部分构成，也就是 <code>has-a</code> 的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。例如一个汽车有 4 个轮子。聚合关系用一条带空心菱形箭头的直线表示。</p><p><img src="/img/2020-12-15-uml/has-a.png" width="50%" style="margin: 0 auto;"></p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系同样表示整体由部分构成，但组合关系是一种强依赖的关系，在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。例如一个人有两只手。组合关系用一条带实心菱形的直线表示。</p><p><img src="/img/2020-12-15-uml/composition.png" width="50%" style="margin: 0 auto;"></p><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联分单向关联和双向关联：</p><ul><li>如果一个类知道或者引用了另一个类，而另一个类不知道或者没有引用这个类，则这两个类是单向关联的。</li><li>双向关联是两个类彼此都知道对方的存在。</li></ul><p>关联关系默认不强调方向，使用普通直线，表示对象间相互知道；如果特别强调方向，可以用带箭头的直线。如下图，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。</p><p><img src="/img/2020-12-15-uml/association.png" width="50%" style="margin: 0 auto;"></p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>与关联关系不同的是，依赖关系是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。依赖也有方向，双向依赖是一种非常糟糕的结构，应该总是保持单向依赖，杜绝双向依赖的产生。</p><p>在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系。依赖关系除了临时知道对方外，还“使用”对方的方法和属性。</p><p>依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如程序员依赖电脑工作。</p><p><img src="/img/2020-12-15-uml/dependency.png" width="50%" style="margin: 0 auto;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h1&gt;&lt;p&gt;总是记不住 UML 那些图例呀，每次要画 UML 图了，就得再上网找一番，索性自己整理一下好了，方便以后查阅。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="programming" scheme="http://anniecyl.github.io/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns</title>
    <link href="http://anniecyl.github.io/2020/12/14/Design-Patterns/"/>
    <id>http://anniecyl.github.io/2020/12/14/Design-Patterns/</id>
    <published>2020-12-14T02:56:08.000Z</published>
    <updated>2020-12-15T05:45:17.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h1><p>面向对象六大设计原则：</p><ul><li>单一职责原则（Single Responsibility Principle，简称SRP）</li><li>开闭原则（Open Close Principle，简称OCP）：对扩展开放，对修改关闭。</li><li>接口隔离原则（InterfaceSegregation Principles，简称ISP）：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li><li>里氏替换原则（Liskov Substitution Principle，简称LSP）：所有引用基类的地方必须能透明地使用其子类的对象。</li><li>依赖倒置原则（Dependence Inversion Principle，简称DIP）：模块间通过接口依赖，实现类之间不发生直接的依赖关系。</li><li>迪米特原则（Law of Demeter，简称LOD）也称为最少知识原则（Least Knowledge Principle）：一个对象应该对其他对象有最少的了解，也就是关于如何松耦合，一个类应该对自己需要耦合或调用的类知道得最少。<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="1-工厂方法（Factory-Method）"><a href="#1-工厂方法（Factory-Method）" class="headerlink" title="1. 工厂方法（Factory Method）"></a>1. 工厂方法（Factory Method）</h3></li></ul><p>简单工厂方法：一个工厂类根据不同的参数创建不同的产品实例对象返回。当有新产品类时，需要修改工厂类中生成实例对象的方法，将这个新产品的判断添加进去来创建新产品的实例对象返回。所以简单工厂方法不符合<code>开放-封闭原则</code>。</p><p><img src="/img/2020-12-14-design-patterns/simple-factory.png" alt="simple-factory"></p><p>工厂方法：一个抽象工厂类，有不同的具体工厂类继承实现。每个具体工厂类创建返回不同的具体产品对象。当有新产品需要添加的时候，只要添加对应的工厂类和新产品类即可，不用去修改已有的工厂类和产品类。所以工厂方法模式符合<code>开放-封闭原则</code>。</p><p><img src="/img/2020-12-14-design-patterns/factory-method.png" alt="factory-method"></p><p><a href="https://www.hollischuang.com/archives/3709" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3709</a></p><h3 id="2-抽象工厂（Abstract-Factory）"><a href="#2-抽象工厂（Abstract-Factory）" class="headerlink" title="2. 抽象工厂（Abstract Factory）"></a>2. 抽象工厂（Abstract Factory）</h3><p>与工厂方法不同的是，抽象工厂针对的是生产一组相关的产品, 即一个产品族。</p><ul><li><p>产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，取子类有海尔电视机、长虹电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构。</p></li><li><p>产品族：在抽象工厂模式中，产品族是指同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p></li></ul><p><img src="/img/2020-12-14-design-patterns/abstract-factory.png" alt="abstract-factory"></p><h3 id="3-生成器（Builder-Pattern）"><a href="#3-生成器（Builder-Pattern）" class="headerlink" title="3. 生成器（Builder Pattern）"></a>3. 生成器（Builder Pattern）</h3><p>也称为建造者模式，将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。</p><p><img src="/img/2020-12-14-design-patterns/builder.png" alt="builder"></p><p><a href="https://refactoringguru.cn/design-patterns/builder" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/builder</a></p><p>使用场景：当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。在 Android 中应用十分广泛，比如 AlerDialog：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>).setTitle(<span class="string">"这是标题"</span>)</span><br><span class="line">        .setMessage(<span class="string">"这是 Message"</span>)</span><br><span class="line">        .setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .setNegativeButton(<span class="string">"取消"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .create()</span><br><span class="line">        .show();</span><br></pre></td></tr></table></figure><h3 id="4-原型"><a href="#4-原型" class="headerlink" title="4. 原型"></a>4. 原型</h3><h3 id="5-单例"><a href="#5-单例" class="headerlink" title="5. 单例"></a>5. 单例</h3><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="1-适配器"><a href="#1-适配器" class="headerlink" title="1. 适配器"></a>1. 适配器</h3><h3 id="2-桥接"><a href="#2-桥接" class="headerlink" title="2. 桥接"></a>2. 桥接</h3><h3 id="3-组合"><a href="#3-组合" class="headerlink" title="3. 组合"></a>3. 组合</h3><h3 id="4-装饰器"><a href="#4-装饰器" class="headerlink" title="4. 装饰器"></a>4. 装饰器</h3><h3 id="5-外观"><a href="#5-外观" class="headerlink" title="5. 外观"></a>5. 外观</h3><h3 id="6-享元"><a href="#6-享元" class="headerlink" title="6. 享元"></a>6. 享元</h3><h3 id="7-代理"><a href="#7-代理" class="headerlink" title="7. 代理"></a>7. 代理</h3><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="1-责任链"><a href="#1-责任链" class="headerlink" title="1. 责任链"></a>1. 责任链</h3><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><h3 id="3-解释器"><a href="#3-解释器" class="headerlink" title="3. 解释器"></a>3. 解释器</h3><h3 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h3><h3 id="5-中介"><a href="#5-中介" class="headerlink" title="5. 中介"></a>5. 中介</h3><h3 id="6-备忘录"><a href="#6-备忘录" class="headerlink" title="6. 备忘录"></a>6. 备忘录</h3><h3 id="7-观察者"><a href="#7-观察者" class="headerlink" title="7. 观察者"></a>7. 观察者</h3><h3 id="8-状态"><a href="#8-状态" class="headerlink" title="8. 状态"></a>8. 状态</h3><h3 id="9-策略"><a href="#9-策略" class="headerlink" title="9. 策略"></a>9. 策略</h3><h3 id="10-模板方法"><a href="#10-模板方法" class="headerlink" title="10. 模板方法"></a>10. 模板方法</h3><h3 id="11-访问者"><a href="#11-访问者" class="headerlink" title="11. 访问者"></a>11. 访问者</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式学习笔记&quot;&gt;&lt;a href=&quot;#设计模式学习笔记&quot; class=&quot;headerlink&quot; title=&quot;设计模式学习笔记&quot;&gt;&lt;/a&gt;设计模式学习笔记&lt;/h1&gt;&lt;p&gt;面向对象六大设计原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（Single Respons
      
    
    </summary>
    
    
      <category term="programming" scheme="http://anniecyl.github.io/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>三月</title>
    <link href="http://anniecyl.github.io/2020/05/28/%E4%B8%89%E6%9C%88/"/>
    <id>http://anniecyl.github.io/2020/05/28/三月/</id>
    <published>2020-05-28T13:38:56.000Z</published>
    <updated>2020-12-11T02:54:09.307Z</updated>
    
    <content type="html"><![CDATA[<p>三月是同事送我的一只英短母猫，在三月之前我其实领养过一只小橘猫，我给她起名字喵喵。但是非常愧疚的是我没照顾好那只小橘猫，没养多久她就去了喵星球，那么粘人温柔的喵喵呀，对不起！</p><p><img src="/img/2020-05-28-三月/miaomiao.jpg" alt="miaomiao"></p><p>所以当同事要送我三月的时候，我其实是很纠结的，因为我怕还是照顾不好。同事说三月已经是成年猫了，健康活泼很好养的，不像只有三个多月的喵喵那样需要特别的照顾的。出于对猫的喜爱，我最后还是答应了。</p><p>于是为了迎接三月，我开始种猫草，精心给她打造一个特别的闺房。</p><p><img src="/img/2020-05-28-三月/prepare.jpg" alt="prepare"></p><p>终于在 2020.03.28 这天两个同事一起把三月送过来了，刚好这也是我辞掉工作的第一天，我们几个同事就在一起好好的吃了一顿火锅，其实挺舍不得离开他们的。</p><p>接下来的日子，我就跟三月朝夕相处，每天沉沦在她的美貌里面不可自拔，各种拍照。</p><p><img src="/img/2020-05-28-三月/sanyue.jpg" alt="sanyue"></p><p>猫刚到一个新环境，是可能会有应激反应的。同事养了三月一年多，没怎么带她出去，也没怎么接触过其他人，所以三月的应激反应就很明显。她每天都不怎么吃不怎么喝，接过来五天后才第一次排便，也是把我给担心得呀。</p><p>但我很快发现三月毕竟已经是一只一岁多的成年猫了，比较难培养感情。每天尝试跟她更亲近些，可她总是对我有戒备心，摸她的话还有可能会咬我。说实话，当时甚至都有点想放弃了。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三月是同事送我的一只英短母猫，在三月之前我其实领养过一只小橘猫，我给她起名字喵喵。但是非常愧疚的是我没照顾好那只小橘猫，没养多久她就去了喵星球，那么粘人温柔的喵喵呀，对不起！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2020-05-28-三月/miaomiao.jpg&quot;
      
    
    </summary>
    
    
      <category term="cat" scheme="http://anniecyl.github.io/tags/cat/"/>
    
  </entry>
  
  <entry>
    <title>美缝</title>
    <link href="http://anniecyl.github.io/2020/05/24/%E7%BE%8E%E7%BC%9D/"/>
    <id>http://anniecyl.github.io/2020/05/24/美缝/</id>
    <published>2020-05-24T13:35:45.000Z</published>
    <updated>2020-12-11T02:54:09.307Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在家装修自己做美缝，虽然做得没有那么完美，但是好歹也 get 到了一个新技能，蛮记录一下做美缝的经验心得。</p><h1 id="美缝的时机"><a href="#美缝的时机" class="headerlink" title="美缝的时机"></a>美缝的时机</h1><p>最好是在地板瓷砖铺完一两个星期后，让地板瓷砖的水泥干透了，在木工进场之前做美缝。因为这个时候地板上没有任何家具遮挡物，方便做美缝。有的人觉得做完木工以后再做美缝，可以省了一些地方（比如衣柜底下）不用做美缝，但是对于稍微有点强迫症的我来说，还是希望可以完整地把美缝做完。</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>一般买美缝剂都会送一套美缝工具，主要包括：</p><ul><li><p>胶枪：需要注意的是，在装上美缝剂以后，如果暂时停下，要将底下黑色那个把手往外抠一下，这样就会松开胶枪，让美缝剂停止往外流。</p><p><img src="/img/2020-05-24-美缝/gun.jpg" alt="gun"></p></li><li><p>压线球：比起压线板条，压线球因为是球形的，不管什么角度压出来的面都是一样的，所以我认为是比压线板条好用。如果希望美缝能平一点，不要太凹下去了，选的压线球就要大一点。</p><p><img src="/img/2020-05-24-美缝/ball.jpg" alt="ball"></p></li><li><p>铲刀：主要用于美缝剂干了以后铲掉多余的美缝剂。</p></li><li>清缝刀：美缝之前需要先清理瓷砖缝隙。如果瓷砖缝隙被水泥填满，固化后不能通过清缝刀清理的话，就要使用电动清缝机。</li><li>手套：手套真的得戴着，不然粘在手上很难清洗。</li><li>小刀：用于削美缝剂胶嘴。</li></ul><h1 id="施工准备"><a href="#施工准备" class="headerlink" title="施工准备"></a>施工准备</h1><ol><li>关好门窗：美缝剂要经过 24 小时才能干，关上门窗可以防止沙土吹进来粘到已经打好的美缝剂上。</li><li>清缝：清缝过程要注意瓷砖缝隙的边缘要整洁，不要粘有水泥或者石头颗粒，否则会影响美缝效果。</li><li>清理灰尘：将要做美缝的地板或者墙面灰尘清理干净，防止在施工过程中有灰尘粘到已经打好的美缝剂上。</li></ol><h1 id="施工"><a href="#施工" class="headerlink" title="施工"></a>施工</h1><ol><li><p>将美缝剂胶嘴斜切一个口子。</p><p> <img src="/img/2020-05-24-美缝/jiaozui.jpg" alt="jiaozui"></p></li><li><p>将美缝剂装上胶枪后，挤掉前面一段未混合完全的美缝剂（一般美缝剂上都会说明这点）。</p></li><li><p>打美缝剂的时候，为了让腰不要太累，要坐着打（刚开始做美缝的时候，没经验，都是蹲着打美缝剂，结果腰都快累断了。。。），先都打一个方向的，第二天这个方向的都干了以后，再打另一个方向的。</p><p> <img src="/img/2020-05-24-美缝/me.jpg" alt="me"></p></li><li><p>打完以后等 5 分钟左右，让美缝剂充分填充到缝隙中。</p></li><li>用压缝球大球压缝，在十字交叉处可以用小球将美缝剂划平一下，方便第二天打另外一个方向的美缝。</li><li>如果后续是要做木工的话，等美缝剂干了再贴上纸胶，防止到时候木屑弄脏美缝，不好清理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间在家装修自己做美缝，虽然做得没有那么完美，但是好歹也 get 到了一个新技能，蛮记录一下做美缝的经验心得。&lt;/p&gt;
&lt;h1 id=&quot;美缝的时机&quot;&gt;&lt;a href=&quot;#美缝的时机&quot; class=&quot;headerlink&quot; title=&quot;美缝的时机&quot;&gt;&lt;/a&gt;美缝的时机&lt;
      
    
    </summary>
    
    
      <category term="life" scheme="http://anniecyl.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Git Q&amp;A</title>
    <link href="http://anniecyl.github.io/2019/07/16/git-q-a/"/>
    <id>http://anniecyl.github.io/2019/07/16/git-q-a/</id>
    <published>2019-07-16T07:16:15.000Z</published>
    <updated>2020-12-11T03:16:51.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="误输密码后一直认证失败"><a href="#误输密码后一直认证失败" class="headerlink" title="误输密码后一直认证失败"></a>误输密码后一直认证失败</h1><p>当 SmartGit 弹出用户名密码时，输错了密码以后不会再弹出用户名密码框而一直认证失败。这时候只要到 <code>控制面板 -&gt; 用户账户 -&gt; 凭据管理器 -&gt; Windows 凭据</code> 里找到需要修正密码的 git 服务器，编辑修改成正确的密码即可。</p><h1 id="在-smartgit-同步-github-工程时一直弹框要求输入用户名和密码"><a href="#在-smartgit-同步-github-工程时一直弹框要求输入用户名和密码" class="headerlink" title="在 smartgit 同步 github 工程时一直弹框要求输入用户名和密码"></a>在 smartgit 同步 github 工程时一直弹框要求输入用户名和密码</h1><ol><li>前提是有生成 ssh 密钥对了（生成密钥对的时候不要设置密码，当然如果要设置密码的话，就要记住这个密码，后续认证或者同步的时候可能需要输这个密码），然后私钥放在本地电脑的 <code>C:\Users\Administrator\.ssh</code> 下，公钥添加到 github 上。</li><li>将工程地址改成 git 开头的，不要用 HTTPS 开头的地址，这样的话 smartgit 就会使用 ssh 密钥对来同步 github 上的工程。两种方式：</li></ol><ul><li>第一种方式：在 smartgit 中右击远程分支，选择 <code>Preferences</code>，将地址改成 git 开头的<br><img src="/img/2019-07-16-git-q-a/origin-properties.png" alt="lfs-file"><br>这个时候 smartgit 可能会要求选择私钥文件，如果生成 ssh 密钥的时候有设置密码，就要设置密码。如果明明已经输对了密码，切换地址还是失败了，那就在 smartgit 的 <code>Edit -&gt; Preferences -&gt; Commands -&gt; Authentication</code> 里面选择 <code>User system SSH client</code>。</li><li>第二种方式：使用命令行操作<ul><li>查看当前方式： <code>git remote -v</code></li><li>先移除旧的 http 的 origin：<code>git remote rm origin</code></li><li>再添加新的 ssh 方式的 origin：<code>git remote add origin git@github.com:xxx/xxx.git</code></li><li>可以再用 <code>git remote -v</code> 检查一下是否改变成功。</li><li>改完之后其实还不能同步工程，因为新的远程分支还没有绑定本地分支，可以使用 <code>git push --set-upstream origin master</code> 绑定，也可以在 smartgit 中操作。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;误输密码后一直认证失败&quot;&gt;&lt;a href=&quot;#误输密码后一直认证失败&quot; class=&quot;headerlink&quot; title=&quot;误输密码后一直认证失败&quot;&gt;&lt;/a&gt;误输密码后一直认证失败&lt;/h1&gt;&lt;p&gt;当 SmartGit 弹出用户名密码时，输错了密码以后不会再弹出用户
      
    
    </summary>
    
    
      <category term="git" scheme="http://anniecyl.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git LFS</title>
    <link href="http://anniecyl.github.io/2019/06/21/Git-LFS/"/>
    <id>http://anniecyl.github.io/2019/06/21/Git-LFS/</id>
    <published>2019-06-21T08:48:28.000Z</published>
    <updated>2020-12-11T02:54:09.306Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://docs.gitlab.com/ee/workflow/lfs/lfs_administration.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/workflow/lfs/lfs_administration.html</a></p><p>首先需要服务端配置支持 LFS（Large File Storage）。</p><p>对于客户端：</p><ul><li>下载安装：<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">https://git-lfs.github.com/</a></li><li>定位到要支持 LFS 的工程目录下，执行 <code>git lfs install</code> 开启 LFS 功能</li><li>执行 <code>git lfs track</code> 命令进行大文件追踪，例如 <code>git lfs track &quot;*.png&quot;</code> 追踪所有后缀为 png 的文件，git 会自动生成 <code>.gitattributes</code> 文件并将 <code>*.png</code> 添加到 <code>.gitattributes</code> 文件中。</li><li>执行 <code>git lfs track</code> 可以查看当前追踪哪些类型的文件，即添加到 <code>.gitattributes</code> 文件中的文件类型。</li><li>将 <code>.gitattributes</code> 文件提交至仓库。</li><li>执行 <code>git lfs ls-files</code> 可以显示当前跟踪的文件列表。</li><li>将文件提交到仓库以后，LFS 跟踪的文件在 gitlab 页面上会以『LFS』的形式显示，如下。<br><img src="/img/2019-06-21-git-lfs/lfs-file.png" alt="lfs-file"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官网：&lt;a href=&quot;https://docs.gitlab.com/ee/workflow/lfs/lfs_administration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.gitlab.com/ee/wo
      
    
    </summary>
    
    
      <category term="git" scheme="http://anniecyl.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>DUKPT</title>
    <link href="http://anniecyl.github.io/2019/02/20/DUKPT/"/>
    <id>http://anniecyl.github.io/2019/02/20/DUKPT/</id>
    <published>2019-02-20T06:54:17.000Z</published>
    <updated>2020-12-11T02:54:09.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul><li>DUKPT：Derived Unique Key Per Transaction</li><li>BDK：Base Derivation Key，DUKPT 密钥体系的根密钥</li><li>IKSN：Initial Key Serial Number</li><li>KSN：Key Serial Number，由 IKSN 和 EC 组成</li><li>EC：Encryption Counter</li><li>IPEK：Initial PIN Encryption Key</li><li>PEK：PIN Encryption Key，加密 PIN 的密钥</li><li>FK：Future Key</li></ul><h1 id="为什么使用-DUKPT"><a href="#为什么使用-DUKPT" class="headerlink" title="为什么使用 DUKPT"></a>为什么使用 DUKPT</h1><p>在 DUKPT 之前，MK/SK 广泛使用，但是会有个问题，不同的终端使用不同的 MK 的话，当要布放的终端数量比较庞大时，收单行就得维护大量的 MK。DUKPT 就解决了这个问题，因为所有的 key 可以从 BDK 衍生，所以只需维护一个 BDK 就行。</p><h1 id="密钥注入过程"><a href="#密钥注入过程" class="headerlink" title="密钥注入过程"></a>密钥注入过程</h1><ol><li>Acquirer 给 POS 灌输 BDK</li><li>BDK + KSN(EC=0)  派生出 IPEK</li><li>IPEK + KSN 派生出 21 个 Future Key，分别存在 POS 的 21 个寄存器中:<ul><li>IPEK + KSN(EC=1) -&gt; FK1，存在寄存器 1</li><li>IPEK + KSN(EC=2) -&gt; FK2，存在寄存器 2</li><li>…</li><li>IPEK + KSN(EC=21) -&gt; FK21，存在寄存器 21</li></ul></li><li>销毁 BDK 和 IPEK</li></ol><h1 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h1><p>一笔交易从一个寄存器中取出一个 PEK 使用，假设取出寄存器 1 中的 FK1 使用， 交易处理完成后：</p><ul><li>KSN 加 1 后变成 KSN(EC=22) </li><li>FK1 + KSN(EC=22) -&gt; FK22，替换掉 FK1 存在寄存器 1 中<br>以此类推依次重复使用这 21 个寄存器中的 FK。</li></ul><p>上述流程只讲解到了 Future Key，但实际用于数据（如 PIN、MAC 等）加密的，其实不是直接拿 Future Key 来用的，而是 Future Key xor 分散向量得到的工作密钥，例如：</p><ul><li><p>PIN 密钥的分散向量：00000000000000FF00000000000000FF</p></li><li><p>MAC 密钥的分散向量：000000000000FF00000000000000FF00 </p><p><img src="/img/2019-02-20-dukpt/derived-keys.png" alt="1"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;DUKPT：Derived Unique Key Per Transaction&lt;/li&gt;
&lt;li&gt;BDK：Ba
      
    
    </summary>
    
    
      <category term="Key Management" scheme="http://anniecyl.github.io/tags/Key-Management/"/>
    
      <category term="PIN Pad" scheme="http://anniecyl.github.io/tags/PIN-Pad/"/>
    
  </entry>
  
  <entry>
    <title>Android FAQ</title>
    <link href="http://anniecyl.github.io/2018/11/08/android-faq/"/>
    <id>http://anniecyl.github.io/2018/11/08/android-faq/</id>
    <published>2018-11-08T02:03:41.000Z</published>
    <updated>2020-12-11T02:54:09.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ 1"></a>FAQ 1</h1><p><strong>No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</strong></p><p>找到自己本地的 android-sdk：<br><img src="/img/2018-11-08-android-faq/as-sdk.jpg" alt="as-sdk"></p><p>打开这个目录后，查看 <code>ndk-bundle</code> -&gt; <code>toolchains</code> 里面是否确实缺少 mips64el 相关的文件。</p><p>解决办法：</p><ul><li><a href="https://developer.android.com/ndk/downloads/?hl=zh-cn" target="_blank" rel="noopener">点击这里</a>下载 NDK 包。</li><li>解压之后打开 <code>toolchains</code> 文件夹，跟本地 <code>toolchains</code> 文件夹做对比，找到其缺少的文件夹，复制过去。</li></ul><h1 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ 2"></a>FAQ 2</h1><p><strong>Installation failed with message Invalid File</strong></p><p>如果设备上应用明明已经卸载了，但是 AS 在 Run 这个应用的时候还是一直提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Installation failed with message Invalid File: xxxx. It is possible that this issue is resolved by uninstalling an existing version of the apk if it is present, and then re-installing.</span><br><span class="line">WARNING: Uninstalling will remove the application data!</span><br><span class="line">Do you want to uninstall the existing application?</span><br></pre></td></tr></table></figure></p><p>可以尝试以下这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings&gt;Build,execute,deployment&gt;Instant run&gt;Enable instant run to hot swap code /resource change on deploy(unchecked this option)</span><br></pre></td></tr></table></figure></p><h1 id="FAQ-3"><a href="#FAQ-3" class="headerlink" title="FAQ 3"></a>FAQ 3</h1><p><strong>Module not specified</strong></p><p>如果 app 模块上有个红叉：<br><img src="/img/2018-11-08-android-faq/module-not-specified-1.png" alt="module-not-specified-1"><br>且运行的时候弹出如下的提示框：<br><img src="/img/2018-11-08-android-faq/module-not-specified-2.png" alt="module-not-specified-2"><br>在 settings.gradle 中，先注释掉 include’：app’，然后单击 File &gt; Sync Project with Gradle files。<br>此后在 settings.gradle 恢复 include’：app’，再 Sync 工程。</p><h1 id="FAQ-4"><a href="#FAQ-4" class="headerlink" title="FAQ 4"></a>FAQ 4</h1><p><strong>ERROR: SSL peer shut down incorrectly</strong></p><p>project 级别的<em>build.gradle</em> 里面把 <code>jcenter()</code> 注释掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125;</span><br><span class="line">//        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FAQ-5"><a href="#FAQ-5" class="headerlink" title="FAQ 5"></a>FAQ 5</h1><p><strong>Command line is too long</strong></p><p>修改项目下 <code>.idea\workspace.xml</code>，找到标签 <code>&lt;component name=&quot;PropertiesComponent&quot;&gt;</code>， 在标签里加一行<code>&lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;</code></p><h1 id="FAQ-6"><a href="#FAQ-6" class="headerlink" title="FAQ 6"></a>FAQ 6</h1><p><strong>Android Studio Build Output 栏内汉字出现乱码</strong></p><p><img src="/img/2018-11-08-android-faq/build-output-mass-code.png" alt="build-output-mass-code"><br>打开 Android Studio 双击 shift 或者点击以下搜索按钮：<br><img src="/img/2018-11-08-android-faq/search.png" alt="search"><br>在搜索框内输入 Edit Custom VM Options：<br><img src="/img/2018-11-08-android-faq/edit-custom-vm-options.png" alt="edit-custom-vm-options"><br>点击第一个选项打开 studio64.exe.vmoptions（若没有此文件，则先创建），添加一句代码 <code>-Dfile.encoding=UTF-8</code>，并编译一下，必须编译，否则 AS 重启的话无法正常打开。<br><img src="/img/2018-11-08-android-faq/studio64-vmoptions.png" alt="studio64-vmoptions"><br>编译以后重启 AS 即可。</p><h1 id="FAQ-7"><a href="#FAQ-7" class="headerlink" title="FAQ 7"></a>FAQ 7</h1><p><strong>Program type already present</strong></p><p>工程结构是这样的：</p><ol><li>lib1 定义的是各种接口文件，导出成 lib1.aar</li><li>lib2 引用 lib1.aar，并对 lib1 的接口进行实现，导出成 lib2.aar</li><li>app 引用 lib1 和 lib2，但是编译的时候一直会提示 <code>Program type already present</code> 的错误，明明只有 lib1 中定义一次的 interface，也还是会提示 <code>Program type already present</code> 这个错误</li></ol><p>各种尝试 <code>implementation</code>、<code>api</code>、<code>compileOnly</code> 来引用这两个 aar，依然会出现这个问题（非常抓狂。。。）。最后看到一个网友说不要使用 <code>implementation fileTree(include: [&#39;*.jar&#39;, &#39;*.aar&#39;], dir: &#39;libs&#39;)</code>，否则就会出现 <code>Program type already present</code> 问题。</p><p>于是终于发现在 app 的 gradle 中要么使用 <code>implementation fileTree(include: [&#39;*.jar&#39;, &#39;*.aar&#39;], dir: &#39;libs&#39;)</code>，一下子引入 libs 下所有的 jar 和 aar：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation fileTree(include: [&apos;*.jar&apos;, &apos;*.aar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">// implementation(name:&apos;lib1&apos;,ext:&apos;aar&apos;)</span><br><span class="line">// implementation(name:&apos;lib2&apos;,ext:&apos;aar&apos;)</span><br></pre></td></tr></table></figure></p><p>要么就是不用 <code>implementation fileTree(include: [&#39;*.jar&#39;, &#39;*.aar&#39;], dir: &#39;libs&#39;)</code>，直接引用具体的 aar：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// implementation fileTree(include: [&apos;*.jar&apos;, &apos;*.aar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">implementation(name:&apos;lib1&apos;,ext:&apos;aar&apos;)</span><br><span class="line">implementation(name:&apos;lib2&apos;,ext:&apos;aar&apos;)</span><br></pre></td></tr></table></figure></p><p>如果同时使用 <code>implementation fileTree</code> 和引用具体的 aar（如下），就会出现 <code>Program type already present</code> 这个错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation fileTree(include: [&apos;*.jar&apos;, &apos;*.aar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">implementation(name:&apos;lib1&apos;,ext:&apos;aar&apos;)</span><br><span class="line">implementation(name:&apos;lib2&apos;,ext:&apos;aar&apos;)</span><br></pre></td></tr></table></figure></p><h1 id="FAQ-8"><a href="#FAQ-8" class="headerlink" title="FAQ 8"></a>FAQ 8</h1><p>在界面添加 Button 的时候，默认 Button 显示的字母都是大写的，即使它的 text 属性设置的都是小写字母。</p><p>解决办法：在 Button 的属性里加上 android:textAllCaps=”false” 即可。</p><h1 id="FAQ-9"><a href="#FAQ-9" class="headerlink" title="FAQ 9"></a>FAQ 9</h1><p><strong>Installed Build Tools revision 29.0.2 is corrupted. Remove and install again using the SDK Manager.</strong></p><p>解决办法：</p><ol><li>Open the SDK manager by clicking on the icon in the top right of Android Studio. (Or go to File &gt; Settings &gt; Appearance &amp; Behavior &gt; System Settings &gt; Android SDK)</li><li>Open <strong>SDK Tools</strong> tab</li><li>At the bottom-right, click “Show Package Details”</li><li>Find <strong>Android SDK Build-Tools</strong> and uncheck the checkbox next to 29.0.2</li><li>Click apply in the bottom of the window. That will delete the component.</li><li>Now check the checkbox next to 29.0.2</li><li>Click apply in the bottom of the window. That will reinstall it.</li></ol><h1 id="FAQ-10"><a href="#FAQ-10" class="headerlink" title="FAQ 10"></a>FAQ 10</h1><p><strong>查看 apk 信息（包名、版本号、版本名称、兼容 api 级别、启动 Activity 等）</strong></p><ol><li>找到 Android SDK 目录下的 <code>build-tools</code> 文件夹，会有不同版本的，随便点开一个，可以看到 aapt</li><li>可以将 aapt 路径添加到环境变量中，也可以直接在 aapt 所在目录下启动命令行工具</li><li>在命令行工具中输入以下命令获取 apk 信息，比如要获取的 apk 是 app-debug.apk，则运行：<code>aapt dump badging app-debug.apk</code>。当然，apk 需要写全路径</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FAQ-1&quot;&gt;&lt;a href=&quot;#FAQ-1&quot; class=&quot;headerlink&quot; title=&quot;FAQ 1&quot;&gt;&lt;/a&gt;FAQ 1&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;No toolchains found in the NDK toolchains folder f
      
    
    </summary>
    
    
      <category term="android" scheme="http://anniecyl.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Navigation</title>
    <link href="http://anniecyl.github.io/2018/11/07/navigation/"/>
    <id>http://anniecyl.github.io/2018/11/07/navigation/</id>
    <published>2018-11-07T02:00:32.000Z</published>
    <updated>2020-12-11T02:54:09.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向上（Up）-vs-返回（Back）"><a href="#向上（Up）-vs-返回（Back）" class="headerlink" title="向上（Up） vs 返回（Back）"></a>向上（Up） vs 返回（Back）</h1><p>看 <a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-principles" target="_blank" rel="noopener">Principles of Navigation</a> 的时候，有点不明白 Up 和 Back 按钮的区别，查了相关资料以后搞明白了：</p><ul><li>Up 按钮用来在应用内，根据应用的逻辑<strong>层级</strong>进行导航，返回到上一个层级，如果某个屏幕已经是该应用的顶层了 (例如，应用的主页)，那不需要 Up 按钮，所以 Up 按钮不会退出应用。</li><li><p>系统的 Back 键则用于按照切换历史返回到之前的<strong>屏幕</strong>。这种导航基于是基于时间轴的，永远是返回到上一个界面视图，而不是基于应用的逻辑层级。</p><p><img src="/img/2018-11-07-navigation/up-vs-back.jpg" alt="up-vs-back"></p></li></ul><p>如果之前的屏幕就是逻辑层次的上一层，那么 Back 和 Up 的行为是一样的。不过和 Up 不同的是，Back 可能回到主屏幕或者其他的应用，Up 回到的屏幕总是在你的应用中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向上（Up）-vs-返回（Back）&quot;&gt;&lt;a href=&quot;#向上（Up）-vs-返回（Back）&quot; class=&quot;headerlink&quot; title=&quot;向上（Up） vs 返回（Back）&quot;&gt;&lt;/a&gt;向上（Up） vs 返回（Back）&lt;/h1&gt;&lt;p&gt;看 &lt;a h
      
    
    </summary>
    
    
      <category term="android" scheme="http://anniecyl.github.io/tags/android/"/>
    
      <category term="navigation" scheme="http://anniecyl.github.io/tags/navigation/"/>
    
  </entry>
  
  <entry>
    <title>AndroidX</title>
    <link href="http://anniecyl.github.io/2018/10/23/AndroidX/"/>
    <id>http://anniecyl.github.io/2018/10/23/AndroidX/</id>
    <published>2018-10-23T08:08:46.000Z</published>
    <updated>2020-12-11T02:54:09.303Z</updated>
    
    <content type="html"><![CDATA[<p>题外话：比起支持，果然还是开发适合我，内心平静了好多。</p><p>官方介绍：<a href="https://developer.android.com/jetpack/androidx/" target="_blank" rel="noopener">AndroidX</a></p><p>迁移步骤：</p><ol><li><p>将 Android Studio 升级到 3.2 以上的版本，project 下的 gradle 里面 <code>com.android.tools.build:gradle</code> 的版本号要改成 <code>3.2.1</code></p></li><li><p>修改 gradle.properties</p><p><code>android.useAndroidX=true</code></p><p><code>android.enableJetifier=true</code></p></li></ol><ol start="3"><li><p>打开 module 下面的 build.gralde 文件</p><ul><li>compileSdkVersion 更改为 28</li><li>targetSdkVersion 更改为 28</li></ul></li><li><p>在AndroidStudio 中执行如下操作：<code>Refactor &gt; Migrate to AndroidX</code></p></li></ol><p>迁移后续：</p><ol><li>由于 <code>Migrate to AndroidX</code> 执行之后，部分控件的包名/路径名的自动转换是有问题的，所以还需要我们手动调整。如：ViewPager，RecyclerView 等，这些内容在迁移完成之后，Android Studio 帮我们自动转换的包名是 <code>androidx.core.weight.xxxx</code>，这是一个错误的包名，我们必须手动修改，否则编译就会出错。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题外话：比起支持，果然还是开发适合我，内心平静了好多。&lt;/p&gt;
&lt;p&gt;官方介绍：&lt;a href=&quot;https://developer.android.com/jetpack/androidx/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AndroidX
      
    
    </summary>
    
    
      <category term="android" scheme="http://anniecyl.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>hexo 问题</title>
    <link href="http://anniecyl.github.io/2018/10/17/hexo-%E9%97%AE%E9%A2%98/"/>
    <id>http://anniecyl.github.io/2018/10/17/hexo-问题/</id>
    <published>2018-10-17T09:16:12.000Z</published>
    <updated>2020-12-11T02:54:09.303Z</updated>
    
    <content type="html"><![CDATA[<p>每次隔一段时间不发布博客，总会冒出新问题。</p><p>这次是执行 <code>hexo d</code> 的时候提示：</p><p><img src="/img/2018-10-17-hexo-问题/hexo-problem-1.jpg" alt="1"></p><p>于是上网搜，反正就是先测试 ssh 是否可以连接，<code>ssh -T git@github.com</code>，然后就可以了：</p><p><img src="/img/2018-10-17-hexo-问题/hexo-problem-2.jpg" alt="2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次隔一段时间不发布博客，总会冒出新问题。&lt;/p&gt;
&lt;p&gt;这次是执行 &lt;code&gt;hexo d&lt;/code&gt; 的时候提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2018-10-17-hexo-问题/hexo-problem-1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://anniecyl.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>CA 证书</title>
    <link href="http://anniecyl.github.io/2018/10/17/CA-%E8%AF%81%E4%B9%A6/"/>
    <id>http://anniecyl.github.io/2018/10/17/CA-证书/</id>
    <published>2018-10-17T08:52:34.000Z</published>
    <updated>2020-12-11T02:54:09.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><ul><li><p>CA 是  <a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">Certificate Authority</a> 的缩写，也叫“证书授权中心”。</p></li><li><p>CA 证书就是由 CA 机构发布的数字证书。</p></li><li><p>SSL（security sockets layer，安全套接层）是为网络通信提供安全及数据完整性的一种安全协议。SSL3.0 版本以后又被称为 TLS。SSL 采用了两种手段：身份认证和数据加密，来保证网络通信的安全和数据的完整性。<strong>身份认证就需要用到 CA 证书了。</strong></p></li><li><p>证书之间的信任关系：就是用一个证书来证明另一个证书是真实可信的。</p></li><li><p>证书信任链：证书之间的信任关系是可以嵌套的。比如，C 信任 A1，A1 信任 A2，A2 信任 A3……这个叫做证书的信任链。只要你信任链上的头一个证书，那后续的证书，都是可以信任的。</p></li><li><p>根证书：假设 C 证书信任 A 和 B，然后 A 信任 A1 和 A2，B 信任 B1 和 B2，则它们之间构成如下的一个树形关系（一个倒立的树）：</p><p><img src="/img/2018-10-17-ca/root-certificate.png" alt="root-certificate"></p><p>处于最顶上的树根位置的那个证书，就是根证书。除了根证书，其它证书都要依靠上一级的证书，来证明自己。那谁来证明根证书的可靠呢？实际上，根证书自己证明自己是可靠的（或者换句话说，根证书是不需要被证明滴）。</p><p>所以根证书是整个证书体系安全的根本。如果某个证书体系中，根证书出了问题（不再可信了），那么所有被根证书所信任的其它证书，也就不再可信了。</p><p>（<a href="https://blog.csdn.net/albertjone/article/details/78166059）" target="_blank" rel="noopener">https://blog.csdn.net/albertjone/article/details/78166059）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CA 是  &lt;a href=&quot;https://en.wikipedia.org/wiki/Certific
      
    
    </summary>
    
    
      <category term="CA" scheme="http://anniecyl.github.io/tags/CA/"/>
    
  </entry>
  
  <entry>
    <title>sublime</title>
    <link href="http://anniecyl.github.io/2018/07/23/sublime/"/>
    <id>http://anniecyl.github.io/2018/07/23/sublime/</id>
    <published>2018-07-23T10:16:52.000Z</published>
    <updated>2020-12-11T02:54:09.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-Package-Control"><a href="#安装-Package-Control" class="headerlink" title="安装 Package Control"></a>安装 Package Control</h1><p><a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装-Package-Control&quot;&gt;&lt;a href=&quot;#安装-Package-Control&quot; class=&quot;headerlink&quot; title=&quot;安装 Package Control&quot;&gt;&lt;/a&gt;安装 Package Control&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="sublime" scheme="http://anniecyl.github.io/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>台湾个人游材料准备</title>
    <link href="http://anniecyl.github.io/2018/07/18/taiwan/"/>
    <id>http://anniecyl.github.io/2018/07/18/taiwan/</id>
    <published>2018-07-18T12:42:44.000Z</published>
    <updated>2020-12-11T02:54:09.301Z</updated>
    
    <content type="html"><![CDATA[<p>虽然是因为出差要去台湾，但是办的是台湾个人游的手续。由于福州人滞留台湾的名声比较坏，所以福州人要去台湾旅游是非常不容易的，有些旅行社为了保证福州人不会滞留台湾，办证都要先交 2 万押金，等到从台湾回来了才会返还这 2 万押金。</p><h1 id="需要办理"><a href="#需要办理" class="headerlink" title="需要办理"></a>需要办理</h1><p>去台湾旅行需要 2 证 1 签注：</p><ul><li>台湾通行证：这是大陆签发的允许大陆居民去台湾的证</li><li>入台证：这是台湾签发的允许大陆居民进入台湾的证</li><li>签注：个人游是办 G 签</li></ul><h1 id="关于通行证和签注"><a href="#关于通行证和签注" class="headerlink" title="关于通行证和签注"></a>关于通行证和签注</h1><p>台湾通行证和签注比较好办理，一般拿着户口本和身份证去出入境就可以办理。</p><p>如果已经有通行证了，在微信上关注“福建省公安厅出入境管理局”公众号，选择：“业务办理” -&gt; “往来台湾旅行签注申请”，填写签注申请以后，可以选择快递服务，邮政就会派人上门收证（台湾通行证），大概 3 个工作日以后会把签注好的通行证再送回来，来回快递只需 20。</p><h1 id="关于入台证"><a href="#关于入台证" class="headerlink" title="关于入台证"></a>关于入台证</h1><p>比较麻烦的是入台证，需要准备很多材料。我这次就提交了以下这些材料：</p><ul><li>本人身份证正反、面扫描件</li><li>本人户口簿页，户口簿首页，户口簿户主页</li><li>紧急联系人身份证正、反面扫描件</li><li>紧急联系人户口簿页</li><li>台湾通行证个人信息页，签注页</li><li>2 寸白底证件照：露耳</li><li>收入证明：我是让公司人力帮忙开了个年收入证明（模板填写要求如下贴图），<a href="/doc/收入证明（模板）.doc">收入证明模板下载</a><br><img src="/img/2018-07-18-taiwan/income.JPG" alt="income"></li><li><a href="/doc/大陸地區人民緊急聯絡人資料表.doc">《大陆地区人民紧急联络人资料表》</a>：填写相关信息以后打印出来签了字再扫描。</li><li><a href="/doc/大陸地區人民申請來臺從事個人旅遊行程表.doc">《大陆地区人民申请来台从事个人旅游行程表》</a>：也是填写完以后打印出来签个字再扫描</li></ul><h1 id="实用工具推荐"><a href="#实用工具推荐" class="headerlink" title="实用工具推荐"></a>实用工具推荐</h1><p>推荐一款手机软件：“扫描全能王”，这个软件可以自动识别四边，把拍出来的证件四边拉正，然后可以导出成图片或者 pdf，不过免费版的导出 pdf 会在页面下方加上该软件的二维码，所以我一般都是导出成图片。我觉得只要拍照的光线够好，拍的时候不要有阴影在照片上，基本上这个软件做出的扫描效果跟用扫描机扫描的差不多了。</p><p><img src="/img/2018-07-18-taiwan/scan1.jpg" alt="scan1"></p><p><img src="/img/2018-07-18-taiwan/scan2.jpg" alt="scan2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然是因为出差要去台湾，但是办的是台湾个人游的手续。由于福州人滞留台湾的名声比较坏，所以福州人要去台湾旅游是非常不容易的，有些旅行社为了保证福州人不会滞留台湾，办证都要先交 2 万押金，等到从台湾回来了才会返还这 2 万押金。&lt;/p&gt;
&lt;h1 id=&quot;需要办理&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="旅游" scheme="http://anniecyl.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="出差" scheme="http://anniecyl.github.io/tags/%E5%87%BA%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>H5 桌面应用开发</title>
    <link href="http://anniecyl.github.io/2018/07/01/h5app/"/>
    <id>http://anniecyl.github.io/2018/07/01/h5app/</id>
    <published>2018-07-01T10:28:17.000Z</published>
    <updated>2020-12-11T02:54:09.300Z</updated>
    
    <content type="html"><![CDATA[<p>我打算自学开发一个 H5 桌面应用出来。目前只是对 js 有些了解，这里先记录一下需要学习的技术：</p><ul><li>HTML5</li><li>Electron：包装 HTML 页面，为网页提供一个本地运行环境。<a href="https://electronjs.org/docs" target="_blank" rel="noopener">https://electronjs.org/docs</a></li><li>Node.js：这个之前用过，相对来说还是比较了解一点</li><li>CSS</li><li>UI </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我打算自学开发一个 H5 桌面应用出来。目前只是对 js 有些了解，这里先记录一下需要学习的技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML5&lt;/li&gt;
&lt;li&gt;Electron：包装 HTML 页面，为网页提供一个本地运行环境。&lt;a href=&quot;https://electron
      
    
    </summary>
    
    
      <category term="H5" scheme="http://anniecyl.github.io/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>《Head First Java》学习笔记</title>
    <link href="http://anniecyl.github.io/2018/06/30/head-first-java/"/>
    <id>http://anniecyl.github.io/2018/06/30/head-first-java/</id>
    <published>2018-06-30T13:04:22.000Z</published>
    <updated>2020-12-11T02:54:09.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li>创建对象时，它会被存放在称为堆的内存区域中，此区域并非普通的堆，它是可回收垃圾的堆。</li><li>没有对象变量这样的东西存在，只有引用到对象的变量，它并不是对象的容器（因为对象都是保存在堆里），而是类似指向对象的指针，或者可以说是地址。</li><li><code>Dog myDog = new Dog();</code> 这样一个语句，其实包含了三个步骤：<ul><li><code>Dog myDog</code> 声明了一个引用变量，java 虚拟机会分配空间给引用变量。</li><li><code>new Dog()</code> 创建一个对象，java 虚拟机会分配堆空间给新建立的 Dog 对象。</li><li><code>=</code> 将新的 Dog 对象与引用变量连接起来了。</li></ul></li><li>对于任意一个 java 虚拟机来说，所有引用变量的大小都一样，不管它实际上所引用的对象大小。但是，不同的 java 虚拟机间可能会以不同的方式来表示引用，因此某个 java 虚拟机的引用大小可能会大于或者小于另一个 java 虚拟机的引用变量。</li><li>一个引用变量如果被标记成 final 的，一旦被指派给某个对象了，就被固定下来了，不能再指派除了这个对象以外的对象给这个引用变量了。</li><li>数组是一个对象，不管里面放的是基础数据类型，还是对象引用。</li><li>实例变量（类的属性字段）默认值： <ul><li>int：0</li><li>float：0.0</li><li>boolean：false</li><li>引用：null</li></ul></li><li>局部变量（方法中定义的变量）没有默认值，如果局部变量没有初始化就要使用的话，编译器会显示错误。</li></ul><h1 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h1><ul><li>多次经常性的小规模发布</li><li>避免加入规格没有的功能，不管“未来”会用到的功能性有多诱人</li><li>先写测试用的程序</li><li>正常工作上下班</li><li>随时随地重构，也就是改善程序代码</li><li>保持简单</li><li>双双结伴进行工作，并经常交换合作伙伴，以便让大家都清楚全局</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li>如果声明一个抽象的方法，就必须将类也标记为抽象的，不能在非抽象类中拥有抽象方法。就算只有一个抽象的方法，此类也要标记为抽象的。</li><li>抽象的方法没有内容，它只是为了标记处多态而存在。它的声明以分号结束。</li><li>抽象类可以带有抽象和非抽象的方法。</li><li>接口的方法带有 <code>public</code> 和 <code>abstract</code> 的意义，它们一定是抽象的，没有内容的。</li><li>extend 只能一个，implement 可以有好多个。</li></ul><h1 id="构造器与垃圾回收器"><a href="#构造器与垃圾回收器" class="headerlink" title="构造器与垃圾回收器"></a>构造器与垃圾回收器</h1><ul><li>在 java 中，程序员会在乎内存中的两种区域：<ul><li>对象的生存空间堆（heap），又称为可垃圾回收的堆</li><li>方法调用及变量的生存空间 栈（stack）</li></ul></li><li>因为对象是存在于堆上，所以实例变量存在于对象所属的堆空间上。实例变量又分两种情况：<ul><li>基础数据类型的实例变量：实例变量的值是存放在对象中，java 会依据数据类型为实例变量留下空间。</li><li>引用的实例变量：java 只会为包含这个引用的对象留下引用所用到的空间，而不是这个引用的对象所用的空间。而引用的对象要等到这个引用被赋值的时候，java 才会给在堆上给这个引用的对象分配空间。</li></ul></li><li>编译器只会在你完全没有写构造函数时才会帮你建一个无参的构造函数。如下：<br>`<br>public ClassName(){<pre><code>super();</code></pre>}<br>`<br>当你已经写了一个有参数的构造函数，但是又需要一个无参的构造函数时，你就要自己手动写一个无参的构造函数。</li><li>如果你有构造函数但没有调用 <code>super()</code>，编译器会帮你对每个重载版本的构造函数加上 <code>super()</code>。编译器帮忙加的一定会是没有参数的版本，即使父类有多个重载版本，也只有无参数的这个版本会被调用到。<code>super()</code> 必须是构造函数的第一个语句。</li><li>使用 <code>this()</code> 来从某个构造函数调用同一个类的另一个构造函数。<code>this()</code> 只能用在构造函数中，且必须是第一行语句。所以，<code>super()</code> 和 <code>this()</code> 不能兼得。</li><li>对象的生命周期完全要看引用到它的“引用”。如果引用还活着，则对象也会继续活在堆上。如果引用死了，对象也就跟着消亡了。</li><li>局部变量只会存活在声明该变量的方法中。实例变量的寿命与对象相同。如果对象还活着，则实例变量也会活着。</li><li>life 与 scope 的区别：只要变量的堆栈块还存在于堆栈上，变量就还活着。但是当此方法调用别的方法时，该变量虽然还活着，但是超出了变量的使用范围。</li><li>有 3 种方法释放对象的引用：<ul><li>引用永久性地离开它的范围，比如一个方法执行结束了，那在这个方法内声明的引用变量就消失了，引用的对象就会变成可回收的了。</li><li>引用被赋值到其他对象上。</li><li>直接将引用设定为 null。</li></ul></li></ul><h1 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h1><ul><li>静态方法不能调用非静态的变量和方法。</li><li>静态变量：被同类的所有实例共享的变量，是在类被加载时初始化的，会在该类的任何对象创建之前、在该类的任何静态方法执行之前初始化的。</li><li>静态变量值必须在声明或者静态初始化程序中赋值。</li><li>通常，java 虚拟机会加载某个类，是因为第一次有人尝试要创建该类的实例，或是使用该类的静态方法或变量。</li><li>关于 final：<ul><li>final 的变量代表不能改变它的值。</li><li>final 的方法代表不能覆盖掉该方法。</li><li>final 的类代表不能继承该类。</li></ul></li><li>如果类只有静态的方法，可以将该类的构造函数标记为 private 的以避免被初始化。</li><li>在 java 中的常量是把变量同时标记为 static 和 final 的。</li><li>Boolean 没有 <code>parseBoolean()</code> 方法，但是 Boolean 的构造函数可以取用 String 来创建对象，如：<code>boolean b = new Boolean(&quot;true&quot;).booleanValue();</code>。</li><li>format 格式化说明：<code>%[argument number][flags][width][.precision]type</code>，其中 <code>[]</code> 里面的都是可选项目，只有 <code>%</code> 和 <code>type</code> 是必要的。<ul><li><code>argument number</code>：如果要格式化的参数超过一个以上，可以在这里指定是哪一个。</li><li><code>flags</code>：特定类型的特定选项，例如数字要加逗号或者正负号。</li><li><code>width</code>：最小的字符数，输出可以超过此宽度，若不足则会自动补零。</li><li><code>.precision</code>：精确度，注意前面有个圆点符号。<br>例如，<code>format(&quot;%,6.1f&quot;, 42.000)</code> 中，<code>%,6.1f</code> 的 <code>,</code> 是 <code>flags</code>，<code>6</code> 是 <code>width</code>，<code>.1f</code> 是 <code>.precision</code></li></ul></li><li><code>&lt;</code> 这个符号是个特殊的指示，用来告诉格式化程序重复利用之前用过的参数。例如：<br><code>String.format(&quot;%tA, %tB %td&quot;, today, today, today);</code><br>可改成：<br><code>String.format(&quot;%tA, %&lt;tB %&lt;td&quot;, today);</code></li><li>要取用当前的日期时间就用 Date，其余功能可以从 Calendar 上面找。</li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>编译器不会注意 RuntimeException 类型的异常。因为大部分的 RuntimeException 都是因为程序逻辑的问题，try/catch 是用来处理真正的异常，而不是程序的逻辑错误。</li><li>有多个 catch 块时要从小排到大。</li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul><li>序列化：object -&gt; ObjectOutputStream(对象被碾平) -&gt; FileOutputStream（对象被当做字节处理）-&gt; 文件</li><li>反序列化：文件 -&gt; FileOutputStream（对象被当做字节读入）-&gt; ObjectInputStream（加载类，加载实例变量的存储值）-&gt; 对象</li><li>序列化程序会将对象版图上的所有东西存储起来。被对象的实例变量所引用的所有对象都会被序列化。</li><li>Serializable 是标记用接口，并没有任何方法需要实现的，它的唯一目的就是声明有实现它的类是可以被序列化的。</li><li>整个对象版图都必须正确地序列化，不然就得全部失败。如果需要序列化的对象中有变量不能被序列化，则这个对象就会序列化失败。如果某实例变量不能或者不应该被序列化，就把它标记为 transient 的。标记为 transient 的变量在恢复的时候是 null（对对象应用而已）或者基础数据类型的默认值。</li><li>如果两个要序列化的对象都有引用实例变量指向相同的对象，那么只有一个对象会被存储，其他引用会复原指向该对象。</li><li>静态变量不会被序列化。因为静态变量代表“每个类一个”而不是“每个对象一个”。所以当对象被还原时，静态变量会维持类中原本的样子，而不是对象存储时的样子。</li></ul><h1 id="网络与线程"><a href="#网络与线程" class="headerlink" title="网络与线程"></a>网络与线程</h1><ul><li>TCP 端口是个 16 位的值。从 0~1023 的 TCP 端口号是保留给已知的特定服务使用，从 1024~65535 可以根据需要来使用。</li><li>一旦建立了连接，客户端可以从 socket 取得底层串流：<br><code>sock.getInputStream()</code></li><li>InputStreamReader 是个转换字节成字符的桥梁。它主要用来链接 BufferedReader 与底层的 Socket 输入串流。<br><code>InputStreamReader stream = new InputStreamReader(sock.getInputStream());</code></li><li>BufferedReader 链接 InputStreamReader 与来自 Socket 的输入串流以读取服务器的文本数据。<br><code>BufferedReader reader = new BufferedReader(stream);</code></li><li>PrintWriter 直接链接 Socket 输出串流，可直接调用 <code>print()</code> 和 <code>println()</code> 输出字符串给服务器。<br><code>PrintWriter writer = new PrintWriter(sock.getOutputStream());</code><br><code>writer.println(&quot;message to send&quot;);</code></li><li>Thread 是工人，Runnable 是这个工人的工作。</li><li>当创建了一个 Thread 对象 t，执行 <code>t.start()</code> 只是让它变成可执行的状态，什么时候真正执行，是 java 虚拟机的线程调度机制来决定的。一旦线程进入可执行状态，它会在可执行与执行中两种状态来来去去，同时也有另一种状态：暂时不可执行（又称为被堵塞状态）</li><li>线程调度器会决定哪个线程从等待状态中被挑出来运行，以及何时把哪个线程送回等待被执行的状态。它会决定某个线程要运行多久，当线程被踢出时，调度器也会指定线程要回去等待下一个机会或者是暂时地堵塞。调度器在不同的 java 虚拟机上面有不同的做法。</li><li>每个对象有一个锁，每个锁只有一把钥匙。通常对象时没有上锁的，当对象有一个或者多个同步化的方法时，线程只有在取得对象锁的钥匙才能进入同步化的方法。</li><li>使用 synchronized 关键词来修饰方法，使它每次只能被单一的线程存取。要保护数据，就把作用在数据上的方法给同步化。所以线程执行时遇上同步化的方法，会认知到它需要对象的钥匙才可以进入该方法。它会取得钥匙（这是由 java 虚拟机来处理的），如果可以拿到钥匙，才可以进入方法，并在完成同步化方法以后放开钥匙。当线程持有钥匙时，没有其他线程可以进入该对象的同步化方法，因为每个对象只有一个钥匙。</li><li>同步化的方法有一些额外的成本：<ul><li>查询钥匙等性能上的损耗</li><li>同步化的方法会让程序因为要同步并行而慢下来</li><li>可能会导致死锁现象<br>原则上应该只做最少量的同步化，可用 synchronized 来修饰一行或者数行的指令而不必整个方法都同步化。</li></ul></li><li>每个被载入的类也是有锁的。所以如果有 3 个 Dog 对象在堆上，则表示有 4 个与 Dog 有关的锁。3 个是 Dog 实例的，一个是 Dog 类的。当你要对静态方法做同步化时，java 会使用类本身的锁。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li>使用 <code>Collections.sort()</code> 方法进行排序的对象需要实现 <code>Comparable</code> 接口，或者使用 <code>Comparator</code>。如果传 <code>Comparator</code> 给 <code>sort()</code> 方法，则排序是由 <code>Comparator</code> 而不是对象的 <code>compareTo()</code> 方法来决定。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><code>&amp;</code> 和 <code>|</code> 通常会用来做位运算，但是用在 boolean 表达式时，会强制 java 虚拟机一定要计算运算符两边的算式。</li><li>使用 import 只是帮你省下每个类前面的包名称而已，程序不会因为用了 import 而变大或变慢。</li><li>像 <code>java.lang</code>，它是一个预先被引用的包，因为 <code>java.lang</code> 是个经常会用到的基础包，所以可以不必 import，<code>java.lang.String</code> 与 <code>java.lang.System</code> 是独一无二的 class，java 会知道要去哪里找。</li><li>内部类可以使用外部所有的方法与变量，就算私用的也一样。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;创建对象时，它会被存放在称为堆的内存区域中，此区域并非普通的堆，它是可回收垃圾的堆。&lt;/li&gt;
&lt;li&gt;没有对象变量这样的东西存
      
    
    </summary>
    
    
      <category term="java" scheme="http://anniecyl.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>完全卸载 parallels desktop</title>
    <link href="http://anniecyl.github.io/2018/06/28/uninstall-parallels-desktop/"/>
    <id>http://anniecyl.github.io/2018/06/28/uninstall-parallels-desktop/</id>
    <published>2018-06-28T11:45:50.000Z</published>
    <updated>2020-12-11T02:54:09.299Z</updated>
    
    <content type="html"><![CDATA[<p>sudo rm -rf /Users/这里改成你的系统用户名/Library/Preferences/com.parallel*</p><p>sudo rm -rf /Users/这里改成你的系统用户名/Library/Parallels</p><p>sudo rm -rf /private/var/db/Parallels</p><p>sudo rm -rf /Library/Logs/parallels*</p><p>sudo rm -rf /Library/Preferences/Parallels</p><p>sudo rm -rf  /private/var/.Parallels_swap</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sudo rm -rf /Users/这里改成你的系统用户名/Library/Preferences/com.parallel*&lt;/p&gt;
&lt;p&gt;sudo rm -rf /Users/这里改成你的系统用户名/Library/Parallels&lt;/p&gt;
&lt;p&gt;sudo rm -
      
    
    </summary>
    
    
      <category term="mac" scheme="http://anniecyl.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>《RxJava2.x 实战》学习笔记</title>
    <link href="http://anniecyl.github.io/2018/06/24/rxjava2x/"/>
    <id>http://anniecyl.github.io/2018/06/24/rxjava2x/</id>
    <published>2018-06-24T02:23:01.000Z</published>
    <updated>2020-12-11T02:54:09.298Z</updated>
    
    <content type="html"><![CDATA[<p>本文中的学习测试代码：<a href="https://github.com/AnnieCyl/rxjavastudy" target="_blank" rel="noopener">https://github.com/AnnieCyl/rxjavastudy</a></p><h1 id="Rx"><a href="#Rx" class="headerlink" title="Rx"></a>Rx</h1><p>Rx = Observables + LINQ + Schedulers</p><h1 id="RxJava-使用三步骤"><a href="#RxJava-使用三步骤" class="headerlink" title="RxJava 使用三步骤"></a>RxJava 使用三步骤</h1><ol><li>创建 Observable</li><li>创建 Observer</li><li>使用 subscribe() 进行订阅</li></ol><h1 id="subscribe-重载方法"><a href="#subscribe-重载方法" class="headerlink" title="subscribe 重载方法"></a>subscribe 重载方法</h1><ul><li>subscribe(onNext)</li><li>subscribe(onNext, onError)</li><li>subscribe(onNext, onError, onComplete)</li><li>subscribe(onNext, onError, onComplete, onSubscribe)</li></ul><h1 id="5-种被观察者类型"><a href="#5-种被观察者类型" class="headerlink" title="5 种被观察者类型"></a>5 种被观察者类型</h1><ul><li>Observable：能够发射 0 或 n 个数据，并以成功或者错误事件终止。</li><li>Flowable：能够发射 0 或 n 个数据，并以成功或者错误事件终止。支持背压，可以控制数据源发射的速度。</li><li>Maybe：能够发射 0 或者 1 个数据，要么成功，要么失败。只有 onComplete、onSuccess 和 onError 事件，三者选其一。</li><li>Single：只发射单个数据或错误事件，只有 onSuccess 和 onError 事件。</li><li>Completable：从来不发射数据，只处理 onComplete 和 onError 事件。可以看成 Rx 的 Runnable。常常结合 <code>andThen</code> 操作符使用。</li></ul><h1 id="do-操作符"><a href="#do-操作符" class="headerlink" title="do 操作符"></a>do 操作符</h1><p>do 操作符可以给 Observable 的生命周期的各个阶段加上一系列的回调监听：（以下基本是按照 do 操作的执行顺序排序）</p><ul><li>doOnSubscribe：一旦观察者订阅了 Observable，它就会被调动。</li><li>doOnLifecycle：可以在观察者订阅之后，设置是否取消订阅。</li><li>doOnNext：Observable 每发射一项数据就会调用它一次，在 onNext 之前执行。</li><li>doOnEach：Observable 每发射一项数据就会调用它一次，在 doOnNext、doOnError 和 doOnComplete 之后，onNext、onError 和 onComplete 之前执行。</li><li>doAfterNext：在 onNext 之后执行。</li><li>doOnComplete：当 Observable 正常终止调用 onComplete 前会被调用。</li><li>doFinally：Observable 终止之后会被调用，无论是正常终止还是异常终止。</li><li>doAfterTerminate：注册一个 Action，当 Observable 调用 onComplete 或者 onError 时触发。</li></ul><h1 id="Hot-Observable-和-Cold-Observable"><a href="#Hot-Observable-和-Cold-Observable" class="headerlink" title="Hot Observable 和 Cold Observable"></a>Hot Observable 和 Cold Observable</h1><h2 id="Hot-Observable"><a href="#Hot-Observable" class="headerlink" title="Hot Observable"></a>Hot Observable</h2><ul><li>无论有没有观察者进行订阅，事件始终会发生</li><li>Hot Observable 与订阅者们的关系是一对多的关系</li><li>好比是一个广播电台，所有此刻收听的听众都会听到同一首歌</li></ul><h2 id="Cold-Observable"><a href="#Cold-Observable" class="headerlink" title="Cold Observable"></a>Cold Observable</h2><ul><li>只有观察者订阅了，才开始执行发射数据流的代码</li><li>Cold Observable 和 Observer 是一对一的关系</li><li>好比是一张音乐 CD，人们可以独立购买并听取它</li><li>just、create、range、fromXXX 等操作符都能生成 Cold Observable</li></ul><h2 id="Cold-Observable-转成-Hot-Observable"><a href="#Cold-Observable-转成-Hot-Observable" class="headerlink" title="Cold Observable 转成 Hot Observable"></a>Cold Observable 转成 Hot Observable</h2><ul><li>使用 <code>publish()</code>，生成 <code>ConnectableObservable</code>。生成的 <code>ConnectableObservable</code> 并不是 subscribe 的时候就发射数据，而是只有对其应用 <code>connect()</code> 的时候才开始发射数据。</li><li>使用 Subject/Processor：Subject 作为观察者，可以订阅目标 Cold Observable，使对方开始发送事件，让 Cold Observable 借助 Subject 转换为 Hot Observable。</li></ul><h2 id="Hot-Observable-转成-Cold-Observable"><a href="#Hot-Observable-转成-Cold-Observable" class="headerlink" title="Hot Observable 转成 Cold Observable"></a>Hot Observable 转成 Cold Observable</h2><ul><li>ConnectableObservable 的 <code>refCount</code> 操作符。RefCount 跟踪有多少个观察者订阅它：<ul><li>如果所有订阅者都取消订阅了，则数据流停止；如果重新订阅，则重新开始数据流。</li><li>如果不是所有订阅者都取消了订阅，而只是部分取消，则部分订阅者重新开始订阅时，不会从头开始数据流。</li></ul></li><li>Observable 的 <code>share</code> 操作符。其实 <code>share</code> 操作符封装了 <code>publish().refCount()</code></li></ul><h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>详细可参见这个链接：<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html</a>          </p><ul><li>AsyncSubject：Observer 会接收 AsyncSubject 的 <code>onComplete()</code> 之前的最后一个数据。<code>subject.onComplete()</code> 必须要调用才会开始发送数据，否则观察者将不接收任何数据。</li><li>BehaviorSubject：Observer 会先接收到 BehaviorSubject 被订阅之前的最后一个数据，再接收订阅之后发射过来的数据。如果 BehaviorSubject 被订阅之前没有发送任何数据，则会发送一个默认数据。</li><li>ReplaySubject：ReplaySubject 会发射所有来自原始 Observable 的数据给观察者，无论它们是何时订阅的。ReplaySubject 可以限制缓存数据的数量（<code>createWithSize()</code>），也可以限制缓存的时间（<code>createWithTime()</code>）。</li><li>PublishSubject：Observer 只接收 PublishSubject 被订阅之后发送的数据。</li></ul><h1 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h1><h2 id="fromArray"><a href="#fromArray" class="headerlink" title="fromArray"></a>fromArray</h2><p>只有当要发送的是<strong>对象数组</strong>时，才会将数组里面的元素一个个发出，否则就是一整个数组发出。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">Observable.fromArray(arr1)</span><br><span class="line">      .doOnNext(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer i)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">"Observable.array1: "</span> + i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .subscribe();</span><br><span class="line">      </span><br><span class="line">Observable.fromArray(arr2)</span><br><span class="line">      .doOnNext(<span class="keyword">new</span> Consumer&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span>[] i)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">"Observable.array2: "</span> + i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .subscribe();</span><br></pre></td></tr></table></figure><p>  以上代码最后输出的是：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.array1: 1</span><br><span class="line">Observable.array1: 2</span><br><span class="line">Observable.array1: 3</span><br><span class="line">Observable.array2: [I@4563e9ab</span><br></pre></td></tr></table></figure><h2 id="repeat、repeatWhen"><a href="#repeat、repeatWhen" class="headerlink" title="repeat、repeatWhen"></a>repeat、repeatWhen</h2><ul><li><p><code>repeat</code> 不是创建一个 Observable，而是重复发射原始 Observable 的数据序列。</p></li><li><p><code>repeatWhen</code> 不是缓存和重放原始 Observable 的数据序列，而是有条件地重新订阅和发射原来的 Observable。</p></li></ul><h2 id="retry、retryWhen"><a href="#retry、retryWhen" class="headerlink" title="retry、retryWhen"></a>retry、retryWhen</h2><ul><li><code>retryWhen</code> 将 <code>onError</code> 中的 <code>Throwable</code> 传递给一个函数，这个函数产生另一个Observable，<code>retryWhen</code> 观察它的结果再决定是不是要重新订阅原始的 Observable。如果这个 Observable 发射了一项数据，它就重新订阅，如果这个 Observable 发射的是<code>onError</code> 通知，它就将这个通知传递给观察者然后终止。</li></ul><h2 id="map、flatMap"><a href="#map、flatMap" class="headerlink" title="map、flatMap"></a>map、flatMap</h2><ul><li>当要转换的数据源是 observable 类型的，则只能用 <code>flatmap</code>，而不能用 <code>map</code></li></ul><h1 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习"></a>补充学习</h1><h2 id="CompositeDisposable"><a href="#CompositeDisposable" class="headerlink" title="CompositeDisposable"></a>CompositeDisposable</h2><p>RxJava 容易造成内存泄漏，在某些情况下没有及时取消订阅导致内存泄漏。CompositeDisposable 可以将 Disposable 统一管理。每当我们得到一个 Disposable 时，就调用 CompositeDisposable.add() 将它添加到容器中, 在退出的时候, 调用 CompositeDisposable.clear() 即可快速解除。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable disposables = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// adding an Observable to the disposable</span></span><br><span class="line">disposables.add(sampleObservable()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribeWith(<span class="keyword">new</span> DisposableObserver&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Observable&lt;String&gt; <span class="title">sampleObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;? extends String&gt; call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// Do some long running operation</span></span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">return</span> Observable.just(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Using clear will clear all, but can accept new disposable</span></span><br><span class="line">disposables.clear(); </span><br><span class="line"><span class="comment">// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable</span></span><br><span class="line">disposables.dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文中的学习测试代码：&lt;a href=&quot;https://github.com/AnnieCyl/rxjavastudy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/AnnieCyl/rxjavastudy&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="RxJava" scheme="http://anniecyl.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>gitlab 镜像工程</title>
    <link href="http://anniecyl.github.io/2018/06/22/gitlab-mirror/"/>
    <id>http://anniecyl.github.io/2018/06/22/gitlab-mirror/</id>
    <published>2018-06-22T12:58:46.000Z</published>
    <updated>2020-12-11T02:54:09.297Z</updated>
    
    <content type="html"><![CDATA[<p>有时候需要在两个 gitlab 服务器之间做镜像文件，这样，在一个服务器上的更改可以同步到另一个服务器上。<br>假设有两个服务器，A 服务器和 B 服务器：</p><ul><li>pull 镜像：在 B 上开发的工程，在 A 上做此工程的 pull 镜像，每次 B 的这个工程有更新，A 会自动 pull 过来。<br>步骤：</li><li>push 镜像：在 A 上开发的工程，做 push 镜像到 B 上，每次 A 的这个工程有更新，A 会自动 push 到 B 上。操作步骤如下：<ul><li>在 B 上创建一个用户，例如 autopush</li><li>如果 B 上还没有对应工程，创建一个对应工程，将 autopush 用户添加到该工程中。然后复制该工程的 http 地址。</li><li>在 A 上进入工程的 Repository 配置 push 镜像<br><img src="/img/2018-06-22-gitlab-mirror/1.png" alt="1"></li><li>将 B 上的工程地址和 autopush 用户组合起来，例如，<a href="http://autopush:password@github.com/annie/demo.git" target="_blank" rel="noopener">http://autopush:password@github.com/annie/demo.git</a><br><img src="/img/2018-06-22-gitlab-mirror/2.png" alt="2"></li><li>如果 B 上这个工程是在某个 group 下，则这个 group 的成员都有对此工程的访问权限，此时需要在此工程的 Member 下把 group 中的每个成员添加为 reporter，因为 B 上这个工程为镜像工程，不能允许有人在镜像工程进行 push 操作。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候需要在两个 gitlab 服务器之间做镜像文件，这样，在一个服务器上的更改可以同步到另一个服务器上。&lt;br&gt;假设有两个服务器，A 服务器和 B 服务器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pull 镜像：在 B 上开发的工程，在 A 上做此工程的 pull 镜像，每次 B 的
      
    
    </summary>
    
    
      <category term="git" scheme="http://anniecyl.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac 上安装 Git</title>
    <link href="http://anniecyl.github.io/2018/06/21/install-git/"/>
    <id>http://anniecyl.github.io/2018/06/21/install-git/</id>
    <published>2018-06-21T11:59:59.000Z</published>
    <updated>2020-12-11T02:54:09.296Z</updated>
    
    <content type="html"><![CDATA[<p>有两种方式在 Mac 上安装 Git：</p><ul><li>安装 homebrew，然后通过 homebrew 安装 Git，具体方法请参考 homebrew 的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></li><li>直接从 AppStore 安装 Xcode，Xcode 集成了 Git，不过默认没有安装，你需要运行 Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</li></ul><p>安装完 Git 其实还没有 <code>.ssh</code> 目录的，要执行生成密钥对的命令以后才会自动生成 <code>.ssh</code> 目录，并且新生成的密钥对都在 <code>.ssh</code> 目录下了。</p><p>要修改密钥的读写权限，否则无法使用 Git。执行以下命令修改权限：<br><code>chmod 644 ~/.ssh/authorized_keys</code><br>如果出现 <code>Permissions 0644 for ‘/root/.ssh/id_rsa’ are too open.</code>等错误显示了，只要把权限降到 <code>0600</code> 就ok了。<br><code>chmod 0600 /root/.ssh/id_rsa</code><br>然后就可以密钥登录了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有两种方式在 Mac 上安装 Git：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装 homebrew，然后通过 homebrew 安装 Git，具体方法请参考 homebrew 的文档：&lt;a href=&quot;http://brew.sh/。&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
      <category term="mac" scheme="http://anniecyl.github.io/tags/mac/"/>
    
      <category term="git" scheme="http://anniecyl.github.io/tags/git/"/>
    
  </entry>
  
</feed>
