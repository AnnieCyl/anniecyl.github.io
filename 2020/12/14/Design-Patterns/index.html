<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Design Patterns</title><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/highlight.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"></head><body><nav class="main-nav"><a href="/">Home</a><a href="/archives">Archives</a><a href="/about">About</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/about"><img class="2x" id="avatar" src="/images/avatar.png"></a><h1>Annie's Blog</h1></header></section></div><section class="post" id="wrapper"><article><header><h1>Design Patterns</h1><h2 class="headline">2020-12-14 10:56:08·1,407 words
·5 minutes read<span class="tags"></span></h2></header><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式学习笔记"><span class="toc-text">设计模式学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建型模式"><span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-工厂方法（Factory-Method）"><span class="toc-text">1. 工厂方法（Factory Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-抽象工厂（Abstract-Factory）"><span class="toc-text">2. 抽象工厂（Abstract Factory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-生成器（Builder-Pattern）"><span class="toc-text">3. 生成器（Builder Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-原型"><span class="toc-text">4. 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-单例"><span class="toc-text">5. 单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构型模式"><span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-适配器"><span class="toc-text">1. 适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-桥接"><span class="toc-text">2. 桥接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-组合"><span class="toc-text">3. 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-装饰器"><span class="toc-text">4. 装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-外观"><span class="toc-text">5. 外观</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-享元"><span class="toc-text">6. 享元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-代理"><span class="toc-text">7. 代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行为型模式"><span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-责任链"><span class="toc-text">1. 责任链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-命令"><span class="toc-text">2. 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-解释器"><span class="toc-text">3. 解释器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-迭代器"><span class="toc-text">4. 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-中介"><span class="toc-text">5. 中介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-备忘录"><span class="toc-text">6. 备忘录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-观察者"><span class="toc-text">7. 观察者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-状态"><span class="toc-text">8. 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-策略"><span class="toc-text">9. 策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-模板方法"><span class="toc-text">10. 模板方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-访问者"><span class="toc-text">11. 访问者</span></a></li></ol></li></ol></li></ol></div><section id="post-body"><h1 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h1><p>面向对象六大设计原则：</p>
<ul>
<li>单一职责原则（Single Responsibility Principle，简称SRP）</li>
<li>开闭原则（Open Close Principle，简称OCP）：对扩展开放，对修改关闭。</li>
<li>接口隔离原则（InterfaceSegregation Principles，简称ISP）：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li>
<li>里氏替换原则（Liskov Substitution Principle，简称LSP）：所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>依赖倒置原则（Dependence Inversion Principle，简称DIP）：模块间通过接口依赖，实现类之间不发生直接的依赖关系。</li>
<li>迪米特原则（Law of Demeter，简称LOD）也称为最少知识原则（Least Knowledge Principle）：一个对象应该对其他对象有最少的了解，也就是关于如何松耦合，一个类应该对自己需要耦合或调用的类知道得最少。</li>
</ul>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="1-工厂方法（Factory-Method）"><a href="#1-工厂方法（Factory-Method）" class="headerlink" title="1. 工厂方法（Factory Method）"></a>1. 工厂方法（Factory Method）</h3><p>简单工厂方法：一个工厂类根据不同的参数创建不同的产品实例对象返回。当有新产品类时，需要修改工厂类中生成实例对象的方法，将这个新产品的判断添加进去来创建新产品的实例对象返回。所以简单工厂方法不符合<code>开放-封闭原则</code>。</p>
<p><img src="/img/2020-12-14-design-patterns/simple-factory.png" alt="simple-factory"></p>
<p>工厂方法：一个抽象工厂类，有不同的具体工厂类继承实现。每个具体工厂类创建返回不同的具体产品对象。当有新产品需要添加的时候，只要添加对应的工厂类和新产品类即可，不用去修改已有的工厂类和产品类。所以工厂方法模式符合<code>开放-封闭原则</code>。</p>
<p><img src="/img/2020-12-14-design-patterns/factory-method.png" alt="factory-method"></p>
<p><a href="https://www.hollischuang.com/archives/3709" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3709</a></p>
<h3 id="2-抽象工厂（Abstract-Factory）"><a href="#2-抽象工厂（Abstract-Factory）" class="headerlink" title="2. 抽象工厂（Abstract Factory）"></a>2. 抽象工厂（Abstract Factory）</h3><p>与工厂方法不同的是，抽象工厂针对的是生产一组相关的产品, 即一个产品族。</p>
<ul>
<li><p>产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，取子类有海尔电视机、长虹电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构。</p>
</li>
<li><p>产品族：在抽象工厂模式中，产品族是指同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p>
</li>
</ul>
<p><img src="/img/2020-12-14-design-patterns/abstract-factory.png" alt="abstract-factory"></p>
<h3 id="3-生成器（Builder-Pattern）"><a href="#3-生成器（Builder-Pattern）" class="headerlink" title="3. 生成器（Builder Pattern）"></a>3. 生成器（Builder Pattern）</h3><p>也称为建造者模式，将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。</p>
<p><img src="/img/2020-12-14-design-patterns/builder.png" alt="builder"></p>
<p><a href="https://refactoringguru.cn/design-patterns/builder" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/builder</a></p>
<p>使用场景：当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。在 Android 中应用十分广泛，比如 AlerDialog：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>).setTitle(<span class="string">"这是标题"</span>)</span><br><span class="line">        .setMessage(<span class="string">"这是 Message"</span>)</span><br><span class="line">        .setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .setNegativeButton(<span class="string">"取消"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .create()</span><br><span class="line">        .show();</span><br></pre></td></tr></table></figure>
<h3 id="4-原型"><a href="#4-原型" class="headerlink" title="4. 原型"></a>4. 原型</h3><p>原型模式是一种对象创建型模式，不是利用类来生成实例，而是通过实例来生成实例。换句话说原型模式就是通过复制现有实例来创建新的实例，无须知道相应类的信息。</p>
<p>使用原型模式创建对象比直接 new 一个对象更有效，因为它是直接对内存进行拷贝，数据对象的内容就全部都有了，不需要重新创建内存区域重新实例化赋值这些操作了，这样的话速度能够快很多。在一些重复创建对象的场景下，就可以使用原型模式来提高对象的创建性能。例如：循环体内创建对象时，就可以考虑用 <code>clone()</code> 的方式来实现。</p>
<p>原型模式的克隆分为浅克隆和深克隆。</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p><img src="/img/2020-12-14-design-patterns/prototype.png" alt="prototype"></p>
<h3 id="5-单例"><a href="#5-单例" class="headerlink" title="5. 单例"></a>5. 单例</h3><p>单例模式能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p>
<p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul>
<li>将默认构造函数设为私有， 防止其他对象使用单例类的 new 运算符。</li>
<li>新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ul>
<p><img src="/img/2020-12-14-design-patterns/singleton.png" alt="singleton"></p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="1-适配器"><a href="#1-适配器" class="headerlink" title="1. 适配器"></a>1. 适配器</h3><h3 id="2-桥接"><a href="#2-桥接" class="headerlink" title="2. 桥接"></a>2. 桥接</h3><h3 id="3-组合"><a href="#3-组合" class="headerlink" title="3. 组合"></a>3. 组合</h3><h3 id="4-装饰器"><a href="#4-装饰器" class="headerlink" title="4. 装饰器"></a>4. 装饰器</h3><h3 id="5-外观"><a href="#5-外观" class="headerlink" title="5. 外观"></a>5. 外观</h3><h3 id="6-享元"><a href="#6-享元" class="headerlink" title="6. 享元"></a>6. 享元</h3><h3 id="7-代理"><a href="#7-代理" class="headerlink" title="7. 代理"></a>7. 代理</h3><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="1-责任链"><a href="#1-责任链" class="headerlink" title="1. 责任链"></a>1. 责任链</h3><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><h3 id="3-解释器"><a href="#3-解释器" class="headerlink" title="3. 解释器"></a>3. 解释器</h3><h3 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h3><h3 id="5-中介"><a href="#5-中介" class="headerlink" title="5. 中介"></a>5. 中介</h3><h3 id="6-备忘录"><a href="#6-备忘录" class="headerlink" title="6. 备忘录"></a>6. 备忘录</h3><h3 id="7-观察者"><a href="#7-观察者" class="headerlink" title="7. 观察者"></a>7. 观察者</h3><h3 id="8-状态"><a href="#8-状态" class="headerlink" title="8. 状态"></a>8. 状态</h3><h3 id="9-策略"><a href="#9-策略" class="headerlink" title="9. 策略"></a>9. 策略</h3><h3 id="10-模板方法"><a href="#10-模板方法" class="headerlink" title="10. 模板方法"></a>10. 模板方法</h3><h3 id="11-访问者"><a href="#11-访问者" class="headerlink" title="11. 访问者"></a>11. 访问者</h3></section><nav id="post-nav"><span class="prev"><a href="/2020/12/15/UML/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"><a href="/2020/05/28/三月/">Older Posts<span class="arrow">→</span></a></span></nav></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/AnnieCyl"><i class="fa fa-github"></i></a></div><p class="small">© Copyright 2018 &nbsp;<i class="fa fa-heart" aria-hidden="true">&nbsp;Annie</i></p><p class="small">Powered by &nbsp;<a href="https://hexo.io/">Hexo &nbsp;</a>Theme By &nbsp;<a href="https://github.com/AnnieCyl/hexo-theme-annie">Annie</a></p></footer></body></html>